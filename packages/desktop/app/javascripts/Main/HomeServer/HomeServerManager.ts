import path from 'path'

import {
  HomeServerManagerInterface,
  HomeServerStatus,
  HomeServerEnvironmentConfiguration,
} from '@web/Application/Device/DesktopSnjsExports'
import { HomeServerInterface } from '@standardnotes/home-server'

import { SafeStorage, WebContents } from 'electron'
import { MessageToWebApp } from '../../Shared/IpcMessages'
import { FilesManagerInterface } from '../File/FilesManagerInterface'
import { HomeServerConfigurationFile } from './HomeServerConfigurationFile'

const os = require('os')

export class HomeServerManager implements HomeServerManagerInterface {
  private readonly HOME_SERVER_CONFIGURATION_FILE_NAME = 'config.json'

  private homeServerConfiguration: HomeServerEnvironmentConfiguration | undefined
  private homeServerDataLocation: string | undefined
  private lastErrorMessage: string | undefined
  private logs: string[] = []

  private readonly LOGS_BUFFER_SIZE = 1000

  constructor(
    private homeServer: HomeServerInterface,
    private webContents: WebContents,
    private filesManager: FilesManagerInterface,
    private safeStorage: SafeStorage,
  ) {}

  async getHomeServerUrl(): Promise<string | undefined> {
    const homeServerConfiguration = await this.getHomeServerConfigurationObject()
    if (!homeServerConfiguration) {
      return undefined
    }

    return `http://${this.getLocalIP()}:${homeServerConfiguration.port}`
  }

  async isHomeServerRunning(): Promise<boolean> {
    const status = await this.homeServerStatus()

    return status.status === 'on'
  }

  async activatePremiumFeatures(username: string): Promise<string | undefined> {
    const result = await this.homeServer.activatePremiumFeatures(username)

    if (result.isFailed()) {
      return result.getError()
    }
  }

  async getHomeServerConfiguration(): Promise<string | undefined> {
    if (this.homeServerConfiguration) {
      return JSON.stringify(this.homeServerConfiguration)
    }

    if (!this.homeServerDataLocation) {
      return undefined
    }

    const homeServerConfiguration = await this.filesManager.readJSONFile<HomeServerConfigurationFile>(
      path.join(this.homeServerDataLocation, this.HOME_SERVER_CONFIGURATION_FILE_NAME),
    )
    if (!homeServerConfiguration) {
      return undefined
    }

    const encryptedConfiguration: HomeServerEnvironmentConfiguration = homeServerConfiguration.configuration
    if (!this.safeStorage.isEncryptionAvailable()) {
      return JSON.stringify(encryptedConfiguration)
    }

    let decryptedConfiguration = {}
    for (const key of Object.keys(encryptedConfiguration)) {
      const configKey = key as keyof HomeServerEnvironmentConfiguration
      const value = encryptedConfiguration[configKey] as string

      const decryptedValue = this.decryptValue(value)

      decryptedConfiguration = {
        ...decryptedConfiguration,
        [key]: decryptedValue,
      }
    }

    return JSON.stringify(decryptedConfiguration)
  }

  async setHomeServerConfiguration(configurationJSONString: string): Promise<void> {
    try {
      if (!this.homeServerDataLocation) {
        throw new Error('Home server data location is not set.')
      }

      const homeServerConfiguration = JSON.parse(configurationJSONString) as HomeServerEnvironmentConfiguration

      await this.filesManager.ensureDirectoryExists(this.homeServerDataLocation)

      let persistableConfiguration = homeServerConfiguration
      if (this.safeStorage.isEncryptionAvailable()) {
        let encryptedConfiguration = {}
        for (const key of Object.keys(homeServerConfiguration)) {
          const configKey = key as keyof HomeServerEnvironmentConfiguration
          const value = homeServerConfiguration[configKey]

          const encryptedValue = this.encryptValue(value)

          encryptedConfiguration = {
            ...encryptedConfiguration,
            [key]: encryptedValue,
          }
        }

        persistableConfiguration = encryptedConfiguration as HomeServerEnvironmentConfiguration
      }

      const configurationFile: HomeServerConfigurationFile = {
        version: '1.0.0',
        info: {
          warning: 'Do not edit this file.',
          information:
            'The values below are encrypted with your user key derived from the OS that the desktop app operates on.',
          instructions: 'Put this file into your home server data location to restore your home server configuration.',
        },
        configuration: persistableConfiguration,
      }

      await this.filesManager.writeJSONFile(
        path.join(this.homeServerDataLocation, this.HOME_SERVER_CONFIGURATION_FILE_NAME),
        configurationFile,
      )

      this.homeServerConfiguration = homeServerConfiguration
    } catch (error) {
      console.error(`Could not save server configuration: ${(error as Error).message}`)
    }
  }

  async setHomeServerDataLocation(location: string): Promise<void> {
    this.homeServerDataLocation = location
  }

  async stopHomeServer(): Promise<string | undefined> {
    const result = await this.homeServer.stop()
    if (result.isFailed()) {
      return result.getError()
    }

    return undefined
  }

  async homeServerStatus(): Promise<HomeServerStatus> {
    const isHomeServerRunning = await this.homeServer.isRunning()

    if (!isHomeServerRunning) {
      return { status: 'off', errorMessage: this.lastErrorMessage }
    }

    return {
      status: 'on',
      url: await this.getHomeServerUrl(),
    }
  }

  async startHomeServer(): Promise<string | undefined> {
    try {
      this.lastErrorMessage = undefined
      this.logs = []

      const homeServerConfiguration = await this.getHomeServerConfigurationObject()
      if (!homeServerConfiguration) {
        await this.setHomeServerConfiguration(JSON.stringify(this.generateHomeServerConfiguration()))
      }

      if (!this.homeServerDataLocation) {
        this.lastErrorMessage = 'Home server data location is not set.'

        return this.lastErrorMessage
      }

      const {
        jwtSecret,
        authJwtSecret,
        encryptionServerKey,
        pseudoKeyParamsKey,
        valetTokenSecret,
        port,
        logLevel,
        databaseEngine,
        mysqlConfiguration,
      } = homeServerConfiguration as HomeServerEnvironmentConfiguration

      const environment: { [name: string]: string } = {
        JWT_SECRET: jwtSecret,
        AUTH_JWT_SECRET: authJwtSecret,
        ENCRYPTION_SERVER_KEY: encryptionServerKey,
        PSEUDO_KEY_PARAMS_KEY: pseudoKeyParamsKey,
        VALET_TOKEN_SECRET: valetTokenSecret,
        FILES_SERVER_URL: (await this.getHomeServerUrl()) as string,
        LOG_LEVEL: logLevel ?? 'info',
        VERSION: 'desktop',
        PORT: port.toString(),
        DB_TYPE: databaseEngine,
      }

      if (mysqlConfiguration !== undefined) {
        environment.DB_HOST = mysqlConfiguration.host
        if (mysqlConfiguration.port) {
          environment.DB_PORT = mysqlConfiguration.port.toString()
        }
        environment.DB_USERNAME = mysqlConfiguration.username
        environment.DB_PASSWORD = mysqlConfiguration.password
        environment.DB_DATABASE = mysqlConfiguration.database
      }

      const result = await this.homeServer.start({
        dataDirectoryPath: this.homeServerDataLocation,
        environment,
      })

      if (result.isFailed()) {
        this.lastErrorMessage = result.getError()

        return this.lastErrorMessage
      }

      this.webContents.send(MessageToWebApp.HomeServerStarted, await this.getHomeServerUrl())

      const logStream = this.homeServer.logs()
      logStream.on('data', this.appendLogs.bind(this))
    } catch (error) {
      return (error as Error).message
    }
  }

  async getHomeServerLogs(): Promise<string[]> {
    return this.logs
  }

  private appendLogs(log: Uint8Array): void {
    this.logs.push(new TextDecoder().decode(log))

    if (this.logs.length > this.LOGS_BUFFER_SIZE) {
      this.logs.shift()
    }
  }

  private generateRandomKey(length: number): string {
    return require('crypto').randomBytes(length).toString('hex')
  }

  private getLocalIP() {
    const interfaces = os.networkInterfaces()
    for (const interfaceName in interfaces) {
      const addresses = interfaces[interfaceName]
      for (const address of addresses) {
        if (address.family === 'IPv4' && !address.internal) {
          return address.address
        }
      }
    }
  }

  private async getHomeServerConfigurationObject(): Promise<HomeServerEnvironmentConfiguration | undefined> {
    try {
      const homeServerConfigurationJSON = await this.getHomeServerConfiguration()
      if (!homeServerConfigurationJSON) {
        return undefined
      }

      return JSON.parse(homeServerConfigurationJSON)
    } catch (error) {
      console.error(`Could not get home server configuration: ${(error as Error).message}`)
    }
  }

  private generateHomeServerConfiguration(): HomeServerEnvironmentConfiguration {
    const jwtSecret = this.generateRandomKey(32)
    const authJwtSecret = this.generateRandomKey(32)
    const encryptionServerKey = this.generateRandomKey(32)
    const pseudoKeyParamsKey = this.generateRandomKey(32)
    const valetTokenSecret = this.generateRandomKey(32)
    const port = 3127

    const configuration: HomeServerEnvironmentConfiguration = {
      jwtSecret,
      authJwtSecret,
      encryptionServerKey,
      pseudoKeyParamsKey,
      valetTokenSecret,
      port,
      databaseEngine: 'sqlite',
      logLevel: 'info',
    }

    return configuration
  }

  private encryptValue(value: string | number | object | undefined): string | object | undefined {
    switch (typeof value) {
      case 'string':
        return this.safeStorage.encryptString(value).toString('hex')
      case 'number':
        return this.safeStorage.encryptString(value.toString()).toString('hex')
      case 'object': {
        const encryptedObject: { [key: string]: string | object | undefined } = {}
        for (const key of Object.keys(value)) {
          const objectKey = key as keyof typeof value
          const objectValue = value[objectKey]
          encryptedObject[key] = this.encryptValue(objectValue)
        }

        return encryptedObject
      }
      default:
        return undefined
    }
  }

  private decryptValue(value: string | object | undefined): string | number | object | undefined {
    switch (typeof value) {
      case 'string': {
        const decryptedValue = this.safeStorage.decryptString(Buffer.from(value, 'hex'))

        return decryptedValue
      }
      case 'object': {
        const decryptedObject: { [key: string]: string | number | object | undefined } = {}
        for (const key of Object.keys(value)) {
          const objectKey = key as keyof typeof value
          const objectValue = value[objectKey]

          decryptedObject[key] = this.decryptValue(objectValue)
        }

        return decryptedObject
      }
      default:
        return undefined
    }
  }
}
